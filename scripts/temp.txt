scripts/
  /config
    Config.js
  /managers
    /base
      Manager.js
    CubeManager.js
    DashletManager.js
    ResourceManager.js
  /platforms
    /base
      Platform.js
    Local.js
    Server.js
  /server
    /middleware
      auth-middleware.js
      rt-middleware.js
    CustomServer.js
  /utils
    lpe.js
    Spinner.js
    synchronize.js
  create.js
  pull.js
  push.js
  start.js


// pull.js
const local = require('./lib/local');
const server = require('./lib/server');
const { synchronize, pullPushInit } = require('./lib/commands');

local.setBaseDir('src');
pullPushInit(() => synchronize(server, local));

// push.js
const local = require('./lib/local');
const server = require('./lib/server');
const { synchronize, pullPushInit } = require('./lib/commands');

local.setBaseDir('dist');
pullPushInit(() => synchronize(local, server));

// commands.js (now moved to separate functions in utils folder)
const md5 = require('md5');
const Spinner = require('cli-spinner').Spinner;
const _colors = require('colors');
const { SingleBar } = require('cli-progress');
const Confirm = require('prompt-confirm');
const chalk = require('chalk');
const { retryOnFail } = require('./utils');
const server = require('./server');
const config = require('./config');
const utils = require('./utils');

async function _loginWithSpinner() {
  const {SERVER, USERNAME, PASSWORD, KERBEROS} = config.getSUPConfig();
  server.setServer(SERVER);

  // authentication
  const authSpinner = new Spinner('Authentication... %s');
  authSpinner.start();
  try {
    const result = KERBEROS ? await retryOnFail(() => server.loginSSO(KERBEROS)) : await retryOnFail(() => server.login(USERNAME, PASSWORD));
    authSpinner.stop();
    console.log('SUCCESS\n');
    return result;
  } catch (err) {
    authSpinner.stop();
    throw err;
  }
}

let loginPromise = null;                                                                            // just to run only once
const loginWithSpinner = () => loginPromise || (loginPromise = _loginWithSpinner());


async function pullPushInit(fnCallback) {
  config.getSUPConfigAndLog();

  try {
    await loginWithSpinner();
  } catch (err) {
    return;
  }

  try {
    await fnCallback();                                                                             // run callback

  } catch (err) {
    if (err.isAxiosError) {
      console.log(chalk.redBright('Network error'));
      if (err.response) {
        console.log('    ', err.response.config.method, err.response.config.url);
        console.log('    ', err.response.status, err.response.statusText);
        console.error(err.response.data);
      } else {
        console.error(err.stack);
      }
    } else {
      console.error(err);
    }
  } finally {
    try {
      await server.logout();
    } catch (err2) {
      // ignore
    }
  }
}


async function enumDashboards(origin) {
  const list = [];
  const schemaNames = await retryOnFail(() => origin.getSchemaNames());
  for (let schemaName of schemaNames) {
    let resources = [];
    resources = await origin.getConfigs(schemaName);
    for (let resource of resources) {
      list.push(`/${schemaName}/${resource}`);
    }
  }
  return list;
}


async function enumCubes(origin) {
  const list =  [];
  const schemaNames = await retryOnFail(() => origin.getSchemaNames());
  for (let schemaName of schemaNames) {
    let cubes = await origin.getCubes(schemaName);
    for (let cube of cubes) {
      list.push(`/${schemaName}/cubes/${cube}`);
    }
  }
  return list;
}


/**
 * load full list of resources
 * @param origin - imported from server or local
 * @returns {Promise<[]>}
 */
async function enumResources(origin) {
  const list = [];
  const schemaNames = await retryOnFail(() => origin.getSchemaNames());
  for (let schemaName of schemaNames) {
    let resources = [];
    resources = await origin.getResources(schemaName);
    for (let resource of resources) {
      list.push(`/${schemaName}/${encodeURIComponent(resource)}`);
    }
  }
  list.sort();
  return list;
}


async function synchronize(fromModule, toModule) {
  const resSpinner = new Spinner('Loading resources list... %s');
  resSpinner.start();

  let fromResources = [],
      toResources = [],
      fromDashboards = [],
      toDashboards = [],
      fromCubes = [],
      toCubes = [];

  try {
    let fromSchemaNames = await retryOnFail(() => fromModule.getSchemaNames());
    let toSchemaNames = await retryOnFail(() => toModule.getSchemaNames());

    if (config.hasResources()) {
      fromResources = await retryOnFail(() => enumResources(fromModule));
      toResources = await retryOnFail(() => enumResources(toModule));
    }

    if (config.hasDashboards()) {
      fromDashboards = await retryOnFail(() => enumDashboards(fromModule));
      toDashboards = await retryOnFail(() => enumDashboards(toModule));
    }

    if (config.hasCubes()) {
      fromCubes = await retryOnFail(() => enumCubes(fromModule));
      toCubes = await retryOnFail(() => enumCubes(toModule));
    }
  } finally {
    resSpinner.stop();
  }
  console.log(` SUCCESS: ${fromResources.length} resources`);

  //
  // collect new, modified and removed resources
  //
  let createItems = [];
  let overwriteItems = [];
  let removeItems = [];

  let createConfigItems = [];
  let overwriteConfigItems = [];
  let removeConfigItems = [];

  const bar1 = new SingleBar({
    format: 'Loading resources content... |' + _colors.cyan('{bar}') + '| {percentage}% || {value}/{total}',
  });
  bar1.start(fromResources.length, 0);

  for (let resource of fromResources) {
    let fromContent = await retryOnFail(() => fromModule.getResourceContent(resource));

    if (toResources.includes(resource)) {                                                           // may be overwrite
      let toContent = await retryOnFail(() => toModule.getResourceContent(resource));
      if (md5(fromContent) !== md5(toContent)) {                                                    // check if content changed
        overwriteItems.push({resource, content: fromContent});
      }
    } else {                                                                                        // has new resource
      createItems.push({resource, content: fromContent})
    }

    bar1.increment();
  }

  if (config.hasDashboards()) {
    for (let config of fromDashboards) {
      const fromContent = utils.cleanPropertyMembers(await retryOnFail(() => fromModule.getConfigContent(config)));

      if (toDashboards.includes(config)) {                                                               // may be overwrite
        let toContent = utils.cleanPropertyMembers(await retryOnFail(() => toModule.getConfigContent(config)));
        if (!utils.compareObjects(fromContent, toContent)) {                                             // check if config changed
          overwriteConfigItems.push({config, content: fromContent});
        }
      } else {                                                                                        // has new config
        createConfigItems.push({config, content: fromContent})
      }
    }
    // if (createConfigItems.length) createConfigItems.length = 1;
    if (!config.getNoRemove()) {
      for (let config of toDashboards) {
        if (!fromDashboards.includes(config)) {
          removeConfigItems.push({config});
        }
      }
    }
  }

  if (config.hasCubes()) {
    for (let config of fromCubes) {
      const fromContent = await retryOnFail(() => fromModule.getCubesContent(config));

      if (toCubes.includes(config)) {                                                               // may be overwrite
        let toContent = await retryOnFail(() => toModule.getConfigContent(config));
        if (!utils.compareObjects(fromContent, toContent)) {                                             // check if config changed
          overwriteConfigItems.push({config, content: fromContent});
        }
      } else {                                                                                        // has new config
        createConfigItems.push({config, content: fromContent})
      }
    }
    if (!config.getNoRemove()) {
      for (let config of toCubes) {
        if (!fromCubes.includes(config)) {
          removeConfigItems.push({config});
        }
      }
    }
  }

  if (!config.getNoRemove()) {
    for (let resource of toResources) {
      if (!fromResources.includes(resource)) {                                                      // extra resources should be removed
        removeItems.push({resource});
      }
    }
    // пропускаем скомпилированные файлы tsx и jsx
    if (removeItems.length) {
      const filteredArr = fromResources.filter((item) => utils.getExtension(item) === 'map');
      let tempArr = [];
      filteredArr.forEach((elem) => tempArr = tempArr.concat(utils.makePathTsxJsx(elem)));
      removeItems = removeItems.filter((item) => !tempArr.includes(item.resource));
    }
  }

  bar1.stop();

  if (createItems.length === 0 && overwriteItems.length === 0 && removeItems.length === 0 &&
    createConfigItems.length === 0 && overwriteConfigItems.length === 0 && removeConfigItems.length === 0) {
    console.log(chalk.green('No changes'));
    return;
  }

  if (createItems.length || createConfigItems.length) {
    console.log('NEW RESOURCES:');
    createItems.forEach(item => console.log('    ', chalk.green(decodeURIComponent(item.resource))));
    createConfigItems.forEach(item => console.log('    ', chalk.green(decodeURIComponent(item.config))));
  }
  if (overwriteItems.length || overwriteConfigItems.length) {
    console.log('OVERWRITE:');
    overwriteItems.forEach(item => console.log('    ', chalk.yellow(decodeURIComponent(item.resource))));
    overwriteConfigItems.forEach(item => console.log('    ', chalk.yellow(decodeURIComponent(item.config))));
  }
  if (removeItems.length || removeConfigItems.length) {
    console.log('REMOVE:');
    removeItems.forEach(item => console.log('    ', chalk.red(decodeURIComponent(item.resource))));
    removeConfigItems.forEach(item => console.log('    ', chalk.red(decodeURIComponent(item.config))));
  }

  if (!config.getForce()) {
    const prompt = new Confirm('Continue?');
    if (!(await prompt.run())) {
      return;
    }
  }

  const bar2 = new SingleBar({
    format: 'Synchronizing resource... |' + _colors.cyan('{bar}') + '| {percentage}% || {value}/{total} Resources',
  });
  bar2.start(createItems.length + overwriteItems.length + removeItems.length, 0);

  try {
    for (let item of createItems) {
      await toModule.createResourceContent(item.resource, item.content);
      bar2.increment();
    }
    for (let item of overwriteItems) {
      await toModule.saveResourceContent(item.resource, item.content);
      bar2.increment();
    }
    for (let item of removeItems) {
      await toModule.removeResourceContent(item.resource);
      bar2.increment();
    }
    for (let item of createConfigItems) {
      const newEntity = await toModule.createJSONContent(item.config, item.content);
      if (newEntity) {
        // так давайте не ругаться матом
        item.content = newEntity;
        await fromModule.createJSONContent(item.config, item.content);
      }
      bar2.increment();
    }
    for (let item of overwriteConfigItems) {
      await toModule.saveJSONContent(item.config, item.content);
      bar2.increment();
    }
    for (let item of removeConfigItems) {
      await toModule.removeJSONContent(item.config, item.content);
      bar2.increment();
    }
  } finally {
    bar2.stop();
  }
}

async function createEntity(local, server, type, schema_name, topicId, dashboard_id, content) {
  if (!schema_name) {
    console.error('You have not typed schema_name');
    return;
  }

  const topicsId = await local.getTopicsId(schema_name);
  let res;
  switch (type) {
    case 'topic': {
      const id = await server.getId({schemaName: schema_name});
      res = await local.createTopic({schemaName: schema_name, id, content});
      console.log(chalk.green(`\nThe topic has been created with id=${id}`));
      return res;
    }
      break;
    case 'dashboard': {
      if (!topicId) topicId = topicsId[0];
      const id = await server.getId({schemaName: schema_name, topicId});
      res = await local.createDashboard({schemaName: schema_name, topicId, id, content});
      console.log(chalk.green(`\nThe dashboard has been created with id=${id}`));
      return res;
    }
      break;
    default: {
      if (!topicId) topicId = topicsId[0];
      if (!dashboard_id) dashboard_id = await server.getId({schemaName: schema_name, topicId});
      const id = await server.getId({schemaName: schema_name, topicId, dashboardId: dashboard_id});
      res = await local.createDashlet({schemaName: schema_name, topicId, dashboardId: dashboard_id, id, content});
      console.log(chalk.green(`\nThe dashlet has been created with id=${id}`));
      return res;
    }
  }
}

module.exports = {
  loginWithSpinner,
  pullPushInit,
  synchronize,
  createEntity,
};

// Local.js
const fs = require('fs');
const fsp = fs.promises;
const path = require('path');
const JSON5 = require('json5');
const { splitResource, filterSchemaNames } = require('./utils');
const Platform = require('./base/Platform');

/**
 * - RefinedAbstraction (bridge pattern)
 */
class Local extends Platform {
  constructor(baseDirectory = path.resolve(__dirname, '..', '..', 'src')) {
    super();
    this.baseDir = baseDirectory;
  }

  setBaseDir(dir) {
    this.baseDir = path.resolve(__dirname, '..', '..', dir);
  }

  async getSchemaNames() {
    const entries = await fsp.readdir(this.baseDir, { withFileTypes: true });
    return filterSchemaNames(
      entries
        .filter(entry => entry.isDirectory())
        .map(entry => entry.name)
    );
  }

  async readFile(filePath) {
    try {
      const fullPath = path.join(this.baseDir, filePath);
      await fsp.stat(fullPath);
      return await fsp.readFile(fullPath);
    } catch (err) {
      return null;
    }
  }

  async writeFile(filePath, content) {
    const fullPath = path.join(this.baseDir, filePath);
    const dir = path.dirname(fullPath);

    try {
      await fsp.stat(dir);
    } catch (err) {
      await fsp.mkdir(dir, { recursive: true });
    }

    await fsp.writeFile(fullPath, content);
  }

  async deleteFile(filePath) {
    const fullPath = path.join(this.baseDir, filePath);
    try {
      await fsp.unlink(fullPath);
    } catch (err) {
      // File doesn't exist, ignore
    }
  }

  async makeDirectory(dirPath) {
    const fullPath = path.join(this.baseDir, dirPath);
    await fsp.mkdir(fullPath, { recursive: true });
  }

  async listFiles(dirPath) {
    const fullPath = path.join(this.baseDir, dirPath);
    const entries = await fsp.readdir(fullPath, { withFileTypes: true });
    return entries.map(entry => ({
      name: entry.name,
      isDirectory: entry.isDirectory(),
    }));
  }
}

module.exports = Local;

// Server.js
const axios = require('axios').default;
const axiosCookieJarSupport = require('axios-cookiejar-support').default;
const tough = require('tough-cookie');
const mime = require('mime-types');
const { splitResource, filterSchemaNames } = require('./utils');
const Platform = require('./base/Platform');

/**
 * - RefinedAbstraction (bridge pattern)
 */
class Server extends Platform {
  constructor() {
    super();
    axiosCookieJarSupport(axios);
    this.cookieJar = new tough.CookieJar();
    this.SERVER = '';
  }

  setServer(server) {
    this.SERVER = server.endsWith('/') ? server.slice(0, -1) : server;
  }

  async getSchemaNames() {
    const url = `${this.SERVER}/api/db/adm.datasets`;
    try {
      const response = await axios.get(url, {
        jar: this.cookieJar,
        withCredentials: true,
      });
      return filterSchemaNames(response.data.map(item => item.schema_name));
    } catch (err) {
      console.warn(`Failed request ${url}`, err.message);
      throw err;
    }
  }

  async login(username, password) {
    const url = `${this.SERVER}/api/auth/login`;
    const result = await axios({
      method: 'post',
      url,
      data: `username=${encodeURIComponent(username)}&password=${encodeURIComponent(password)}`,
      headers: {'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'},
      jar: this.cookieJar,
      withCredentials: true,
    });
    return result.data;
  }

  async logout() {
    const url = `${this.SERVER}/api/auth/logout`;
    await axios.get(url, {
      jar: this.cookieJar,
      withCredentials: true,
    });
  }

  // Server-specific HTTP methods that managers will use
  async get(endpoint, options = {}) {
    const url = `${this.SERVER}${endpoint}`;
    return axios.get(url, {
      jar: this.cookieJar,
      withCredentials: true,
      ...options,
    });
  }

  async post(endpoint, data, options = {}) {
    const url = `${this.SERVER}${endpoint}`;
    return axios.post(url, data, {
      jar: this.cookieJar,
      withCredentials: true,
      ...options,
    });
  }

  async put(endpoint, data, options = {}) {
    const url = `${this.SERVER}${endpoint}`;
    return axios.put(url, data, {
      jar: this.cookieJar,
      withCredentials: true,
      ...options,
    });
  }

  async delete(endpoint, options = {}) {
    const url = `${this.SERVER}${endpoint}`;
    return axios.delete(url, {
      jar: this.cookieJar,
      withCredentials: true,
      ...options,
    });
  }
}

module.exports = Server;

// Platform
const ResourceManager = require('../../managers/ResourceManager');
const DashletManager = require('../../managers/DashletManager');
const CubeManager = require('../../managers/CubeManager');

/**
 * Abstract base class representing a data storage platform.
 * Both Local and Server classes will inherit from this
 * - Abstraction (bridge pattern)
 */
class Platform {
  constructor() {
    this.resourceManager = new ResourceManager(this);
    this.dashletManager = new DashletManager(this);
    this.cubeManager = new CubeManager(this);
  }

  // Core platform operations that managers will use
  async getSchemaNames() {
    throw new Error('getSchemaNames must be implemented');
  }

  // Each platform should implement only these core methods
  // that are used by managers
  async readFile(path) {
    throw new Error('readFile must be implemented');
  }

  async writeFile(path, content) {
    throw new Error('writeFile must be implemented');
  }

  async deleteFile(path) {
    throw new Error('deleteFile must be implemented');
  }

  async makeDirectory(path) {
    throw new Error('makeDirectory must be implemented');
  }

  async listFiles(path) {
    throw new Error('listFiles must be implemented');
  }

  // Authentication methods for ServerPlatform
  async login(username, password) {
    throw new Error('login must be implemented');
  }

  async logout() {
    throw new Error('logout must be implemented');
  }
}

module.exports = Platform;


// Manager.js
/**
 * - Implementor (bridge pattern)
 */
class Manager {
  constructor(platform) {
    // Connect with Abstraction
    this.platform = platform;
  }

  async getContent(resource) {
    throw new Error('getContent must be implemented');
  }

  async saveContent(resource, content) {
    throw new Error('saveContent must be implemented');
  }

  async createContent(resource, content) {
    throw new Error('createContent must be implemented');
  }

  async removeContent(resource) {
    throw new Error('removeContent must be implemented');
  }

  async enumerate(schemaName) {
    throw new Error('enumerate must be implemented');
  }
}

module.exports = Manager;

// CubeManager.js
const Manager = require('./base/Manager');

/**
 * - ConcreteImplementor (bridge pattern)
 */
class CubeManager extends Manager {
  async getContent(cube) {
    const [_, schemaName, __, cubePath] = cube.split('/');
    return this.platform.getCubeContent(schemaName, cubePath);
  }

  async saveContent(cube, content) {
    return this.platform.saveJSONContent(cube, content);
  }

  async createContent(cube, content) {
    return this.platform.createJSONContent(cube, content);
  }

  async removeContent(cube) {
    return this.platform.removeJSONContent(cube);
  }

  async enumerate(schemaName) {
    const cubes = await this.platform.getCubes(schemaName);
    return cubes.map(cube => `/${schemaName}/cubes/${cube}`);
  }
}

module.exports = CubeManager;

// DashletManager.js
const Manager = require('./base/Manager');

/**
 * - ConcreteImplementor (bridge pattern)
 */
class DashletManager extends Manager {
  async getContent(config) {
    return this.platform.getConfigContent(config);
  }

  async saveContent(config, content) {
    return this.platform.saveJSONContent(config, content);
  }

  async createContent(config, content) {
    return this.platform.createJSONContent(config, content);
  }

  async removeContent(config) {
    return this.platform.removeJSONContent(config);
  }

  async enumerate(schemaName) {
    const configs = await this.platform.getConfigs(schemaName);
    return configs.filter(config => !config.includes('index.json'))
      .map(config => `/${schemaName}/${config}`);
  }
}

module.exports = DashletManager;

// ResourceManager.js
const Manager = require('./base/Manager');

/**
 * - ConcreteImplementor (bridge pattern)
 */
class ResourceManager extends Manager {
  async getContent(resource) {
    return this.platform.getResourceContent(resource);
  }

  async saveContent(resource, content) {
    return this.platform.saveResourceContent(resource, content);
  }

  async createContent(resource, content) {
    return this.platform.createResourceContent(resource, content);
  }

  async removeContent(resource) {
    return this.platform.removeResourceContent(resource);
  }

  async enumerate(schemaName) {
    const resources = await this.platform.getResources(schemaName);
    return resources.map(resource => `/${schemaName}/${encodeURIComponent(resource)}`);
  }
}

module.exports = ResourceManager;
